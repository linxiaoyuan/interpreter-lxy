# 一张疆域地图

> 即使多粗糙都好，你必须要有一张地图，不然你会四处瞎晃找不到目的地。在指环王的世界里，我总是控制里面的角色而不至于让他们走得太远。 --JRR Tolkien

我们不想四处瞎转，所以在出发前，我们一起看看前一种语言实现的疆域图纸。我会帮助你们了解我们要去哪里以及可选的道路有哪些。

首先，我们先对这本书有个大致的了解。此书的大部分内容是在讲一个编程语言的实现，这有别于具有某种柏拉图式理想形态的语言本身。像堆栈，字节码，递归下降等，就是一个具体语言实现会用到的细节。从使用者的角度上看，只要最终完成的神奇装置能够按照语言说明书正确运行，那么他们都是实现细节而已。

我们会在这些细节上花很多时间和精力，所以如果每一次提到语言实现这个词汇我都要完整写出来的话，我的手指可能会写废掉。因此，除非有特别明显的区别，我会用语言这个词指代语言和实现，或者语言实现这几个词汇。

## 一门语言的主要部分

工程师在计算机的黑暗时代就开始发明程序语言了。为了尽快能和计算机对话（我们发现这是特别难的事），我们向他们寻求帮助。我发现神奇的是即使今天的机器已经千万倍的快速和拥有巨量的存储了，我们创造编程语言的方式还是一成不变。

尽管设计者划下的语言的版图十分巨大，但他们在其中开辟的道路却很少。不是所有的语言都采用完全一样的道路，有些可能会走一两条捷径，但他们大部分都是相似的。从海军少将Grace Hopper 的第一个COBOL编译器到如今火热的某些放在git仓库里文档只有简单的README的JavaScript转换器，都是类似的实现方式。

> 虽然死路肯定会有，但研究这些死胡同的CS论文不会有人引用也没人去优化它，也就只有把内存分成一个个字节去测量时，才能稍显意义。

我把攀登实现语言这座高山的路线网络画了出来，你会从山脚下开始，那里只有粗糙的源码文本，事实上只是一些字符串而已。每一个阶段都会分析代码并转化成更高层级的表现形式，层级更高也意味着语义，作者希望计算做的事情，越清晰。

最后我们会到达山顶。我们可以鸟瞰用户的程序并知道他们的代码是什么含义。下一步，我们从另一边下山。我们逐步把高层级的表达转换成低层级的，慢慢接近CPU实际运行的语言形态。

![The branching paths a language may take over the mountain.](http://craftinginterpreters.com/image/a-map-of-the-territory/mountain.png)

我们一起来跟一下感兴趣的路径和节点。我们的路程从下面这句用户源码开始。

![var average = (min + max) / 2;](http://craftinginterpreters.com/image/a-map-of-the-territory/string.png)

### 扫描

第一步是扫描，也叫分词，或者如果你想让人印象深刻的话也可以叫词法分析。他们都是一个意思。我比较喜欢“分词”这个词，因为听起来像某个邪恶坏蛋会做的事，但我会用扫面这个词，因为它稍微普遍一些。

一个扫描器接受一个线性的符号流，然后把他们拼成一个个类似单词形态的东西。在编程语言里，这种单词叫做令牌（token）。有些tokens只有一个符号，如“（”和“，”。有些有几个符号的长度，如数字（123），字符串（“hi！”），或者标识符（min）。

> Lexical 来自希腊词根 lex，意为“单词”。

源文件里，有些字符是没有意义的。空格不是很重要，注释也会被语言忽略。扫描器常常会忽略它们，保留一个干净的有意义的token队列。

![[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]](http://craftinginterpreters.com/image/a-map-of-the-territory/tokens.png)



### 解析

接下来就是解析了。在这里我们的句式将获得语法能力，这种能力可以把各个小模块组织成完整的表达式。你是否在英语课上图解过句子呢。如果有那你做的事就是解析器做的了，不同的是英语有成千上万的“关键词”和各种模凌两可的句式。编程语言可比这简单多了。

一个解析器会把一个平整的token队列解析成一个树结构，这也是语法的可嵌套特质。这些树有好几个名字，解析树，抽象语法树，这取决于源码语言有多接近纯粹的句法结构。实际上，语言hacker经常把它们称做为“语法树”，“ASTs",或者只是“树”。

![An abstract syntax tree.](http://craftinginterpreters.com/image/a-map-of-the-territory/ast.png)

解析过程在计算机科学里面历史悠久，而且和人工智能联系也非常紧密。今天用来解析编程语言的工具，在以前是AI研究者构建出来解析人类语言的，他们试图让机器人和人类对话。

最后证明，对于那些解析器能够识别的死板的语法而言，人类语言太杂乱无章了，但解析器却与编程语言的人造语法适配地很好。可悲的是，我们愚蠢的人类仍然不能正确地使用那些简单的语法，所以解析器的工作也包括了告诉人们哪里有语法错误。

### 静态分析

在两种实现中，前面两个阶段都很非常相似，但从这里开始，语言各自的特点会慢慢显现出来。此时此刻，我们知道代码的语法结构，比如操作符优先级和表达式嵌套，但除此之外没有再多信息。

在一个像 a + b 的表达式中，我们知道是 a 和 b 相加，但是我们并不知道两个名字代表着什么，他们是局部变量，全局？哪里定义的？

很多语言的分析第一步骤叫做绑定或者决议。对于每一个标识符，我们要找到名字是在哪定义的并将他们联系在一起。这时候作用域就起作用了，它定义了某个名字能够指向某个声明的源码范围。

如果语言是静态类型的，那么在这个阶段也会做类型检查。一旦我们知道a和b在哪声明的，那么我们也能找出那么的类型。接着，如果它们的类型不支持他们加加法运算，则我们报出一个类型错误。

> 我们在这本书里创建的语言是动态类型语言，所以它会在稍后的运行时做类型检查

深呼吸。现在我们已经到达了山峰看到了用户程序的全貌。所有从分析所得的语义内景需要存储在某个地方。有几个地方我们可以用来藏这些东西：

* 通常，他们会作为节点的属性放在语法树中。这些节点的额外空间在解析阶段不会初始化，但会在后续的阶段填充数据
* 其他时候，我们把数据存在一个查找表中，一般我们会把变量的声明名字也就是标识符当作表的键名。在这种情况下，我们把它称为符号表，表中键所对应的值可以告诉我们标识符指向的是什么。
* 最好的记录方式是把树转换成一个全新的数据结构，可以更直接的表达代码中的语义。下一章节我们会讨论这个问题。

至此的所有内容我们认为是实现的前端部分，你可能会觉得此后的内容是属于后端的，但是不是。很久以前，在“前端”和“后端”概念创造出来的时候，编译器是非常简单的。后来一些研究者把新的阶段塞进了这两者之间。William Wulf 和一些公司没有抛弃旧的叫法，他们创造一个“中端”的概念，融合进旧的体系中。“中端”听起来挺有吸引力，但字面上却是空间矛盾的。

###  中介码

你可以把编译器看成一个管道，管道里每一个阶段做的事就是组织代码使之在接下来的阶段容易被实现。管道的前端专注于用户编程所用的源码语言，后端则关注代码最终运行的组织架构。

在中间，代码可能会以中介码（IR）的形态存储，这种形态与源码和目标代码联系都不是很紧密。IR在前后两种语言之间扮演了接口的角色。

> 这里有几个已经得到公认的IR特性。用你的搜索引擎查找下“控制流图”，“静态单赋值”，“延续传递风格”，“三地址码”。

这让你可以轻而易举地支持多种源码和目标平台。比如说你行实现Pascal，C和Fortran编译器并且支持x86,arm,Idunno，SPARC平台。通常来说，这意味着你要实现9个编译器：Pascal→x86, C→ARM,以及其他组合。

一个可共享的中介码可以很大程度减少实现数量。你可以为每一个源码语言写一个可以翻译成IR的前端，然后再为每一个平台写一个后端，然后把这些排列组合就能满足前面9个编译器的需求了。

> 如果你想了解GCC是怎么支持众多语言和平台的，诸如Modula-3 on Motorola 68k，现在你应该知道了吧。前端的语言翻译成某种IR，通常是GIMPLE和RTL，然后目标后端比如68K把这些IR翻译成本地机器码。

我们之所以想把代码转换成语义更清晰的形式，还有一个很重要的原因。。。

### 优化

一旦我们了解了用户程序的含义，我们就可以自由地把它换成一个相同语义但更高效的程序，这就是优化。

一个简单的例子就是常量折叠：如果一个表达式总是等于一个确定的值，那么我们就可以在编译阶段把表达式替换成它的结果。比如，如果用户输入以下内容：

``` pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);
pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);
```

我们在编译器做计算染回把代码替换成：

``` pennyArea = 0.4417860938;
pennyArea = 0.4417860938;
```

优化在编程语言里是很大的一个议题。很多语言黑客倾尽他们的职业生涯来做优化，竭尽所能的挤出任何一点性能来使他们的编译器比基准线快个百分之零点几个点。这算是某种痴迷了。

在本书我们将跳过这个老鼠洞（没有止境）。很多成功的语言只有很少的编译期优化，比如Lua和CPython生成的代码并不没优化过，他们更更关注的是运行时的性能。

> 如果你还是忍不住伸脚进入这个老鼠洞，那么有几个关键词可以帮你入门，它们是：“constant propagation”, “common subexpression elimination”, “loop invariant code motion”, “global value numbering”, “strength reduction”, “scalar replacement of aggregates”, “dead code elimination”, 和 “loop unrolling”.

### 代码生成

我们已经把所能想到的优化都用到用户的程序上了。最后一步便是把它转换成机器能运行的格式，这就是代码生成。这里的代码指的不是人阅读的源码，而是CPU运行的嵌入式形式的某种指令集。

最终我们来到了后端，从山的另一边开始往下走了。从这里开始，我们代码的形态变得越来越底层，就像进化的逆过程一样，我们会慢慢接近头脑简单的机器能够理解的东西。

我们需要做一个决定，我们生成的指令是要用在真实的CPU还是虚拟的CPU上。如果选择生成真实的机器码，那么我们能拿到一个能直接在芯片上跑的可执行程序。本地代码运行十分迅速，但生成它们却十分费劲。今天的芯片架构有一堆指令，复杂的管道技术以及能够塞进一辆747飞机的历史包袱。

使用芯片语言也意味着你的编译器绑定了一个特定的架构。如果你的编译器的目标是x86机器码，那你就不能运行在ARM设备上。缺乏移植性是一个真正的障碍，这事可以追溯到上世纪60年代，正值计算机架构的寒武纪大爆发。

> 比如，AAD指令（ASCII Adjust AX Before Division）让你可以做触法运算，这听起来很有用，但它需要把两个二进制形式的十进制数字打包进一个16位的寄存器中。你上次在16位的机器里寻找BCD又是什么时候呢。

为了回避这种情况，Martin Richards and Niklaus Wirt，有着BCPL 和 Pacal的声望，各自使他们的编译器编译出虚拟机代码。我们为想象中的理想机器生成代码，而不是生成真实机器的指令集。Wirth 把这称为P-code寓意是可移植的，但今日我们一般叫他字节码因为指令一般都是单个字节的长度。

这些合成的指令集被设计得更贴近语言的语义，并且和计算机架构和它们的历史包袱这些奇奇怪怪的东西的关系也不大。你可以把它想成一个语言底层操作的密集二进制编码。

### 虚拟机

如果你的编译器生成的是字节码，那么做完这个事情还没有结束，因为没有任何一个芯片能够读懂字节码，所以你还要继续翻译它们。你可以为每一个目标架构都写一个小的编译器，把你的字节码转换成机器本地代码。虽然你还是需要为每一个你支持的芯片工作，但最后的这个阶段是比较简单的，而且你可以复用剩余的编译器管道来覆盖你所支持的机器。

> 这里最基本的原则是，使用于特定架构的管道你埋得越深，那么你就能在更多的时期里共享这些管道。但是这其实是对立的。许多优化措施，比如寄存器的分配和指令集的选择，会再我们清楚特定芯片的优点和能力的时候工作得更好。找出哪些是可以共享的，哪些又是针对特定机器实现的是一种门艺术。

或者你可以写一个虚拟机（VM），它可以在运行时模拟出一个芯片来支持你的架构。在VM里跑字节码会比提前把它翻译成本地码要慢得多，因为运行时的每一条指令都需要在每次调用时模拟成本地指令。而回报是，你获得简化和可移植。实现你的VM，比如用C语言，那你就可以在任何平台上跑你的语言，只要它有C编译器。这也是我们第二个解释器要做的事情。

### 运行时

我们已经把用户的程序锤炼成可执行的形态了。最后一步就是运行它。如果我们把它编译成机器码，那我们让操作系统加载可执行文件然后让他跑就好了。如果我们编译成字节码，那么我们还要开启VM然后把程序载入其中。

对于绝大多数语言，我们通常需要语言在程序运行时提供一些服务支持。比如如果语言支持自动管理内存，那么我们需要一个垃圾回收器收回没用的比特位。如果语言支持实例检查，那么你可以知道你的对象是什么类型，我们就需要一些特性在运行期间跟踪每个对象的类型。

所有这些都是在运行期间，emm，所以我们叫它运行期。在完整的编译语言中，代码把实现的运行时直接加进可执行文件里。比如go语言，每一个编译好的程序都有它自己运行时拷贝。如果语言在解释器和VM上跑，那么运行时也在那里。这也是大多是的语言比如Java，Python，和JavaScript的机制。

## 捷径和可替代的道路

走完所有实现解释器的所有可能阶段是十分漫长的，很多语言走完了所有路径，但还是有些捷径和其他替换的道路

###单程编译器

有些简单的编译器把解析，分析，和代码生成交织在一起，这样就能在解析器里 直接输出代码，而不用生成语法树和IR。单程编译器对语言的设计做了很多限制。你没有中间形态的数据结构来存储程序的全局信息，也不能重新访问前面阶段已经处理过的代码。这意味着你一碰到一个表达式就需要知道如何去正确的编译它。

> 语法导向的翻译是创建这些一步到位编译器的结构化技术。你把一个动作和通常是生成输出的代码的语法联系在一起，然后无论解析器在什么时候匹配到了某个语法块，他都会执行相应的动作，每一次为目标代码创建一条规则。

Pascal 和 C 语言就是在这种限制下设计出来的。那个时候内存是很宝贵的，编译器能占有的内存比程序少的多，它无法加载整个源文件。这就是为什么Pascal需要把类型声明放在block的最前面。这也是为什么C语言不能在方法定义的上面调用它，除非有明确的前置声明来告诉编译器去为这样的调用生成而外代码。

### 树径解释器（Tree-walk）

有些程序语言会在把代码解析成抽象语法树（AST）之后就开始执行它。为了运行程序，它每次会访问一个语法树的分支和叶子，以此来评估每个节点。这种解释器通常出现在学生作业和小语言项目中，它比较慢，使用并不广泛。一个比较重要的例外就是Ruby在他1.9版本之前用的正是树径解释器。

> 在1.9版本，Ruby的权威实现从原来的MRI (“Matz’ Ruby Interpreter”) 换成了Koichi Sasada’s YARV (“Yet Another Ruby VM”).。YARV是一个字节码虚拟机

有些人用解释器来特指这类型的实现，但这个词的其他定义使用更广泛，所以我用没有歧义的“树径解释器”来特指它。我们的第一个解释器就是按这种方式运行的。

### 转译器

完整地实现一个语言的后端有很大的工作量。如果你已经有了通用的IR，你可以把你的前端衔接上去，否则你就会给困住了。但如果我们把另一种源码语言当成中介码呢？

我们先为自己的语言写个前端，然后在后端，在之前我们是将语义降低成底层的目标语言，但现在我们可以转成和我们的语言同样高级的其他语言的源码。接下来我们使用其他语言的编译工具来从编译器山峰走到某个具体能执行的阶段。

我们把这称为“源码到源码编译器”，或者“转译器”（**transcompiler**），越来越多的语言选择编译成JavaScript以此来在浏览器中运行，慢慢得这个词变成了**transpiler**

> 第一个转译器，XLT86，把8080汇编转译成8086汇编。这看起来很简单，但是你要知道，8080是8位芯片，8086是16位芯片，8086可以把一个寄存器当成一对8080的寄存器使用。XLT86分析数据流来跟踪寄存器在原程序的使用情况，然后高效地把它们映射在8086的寄存器集上。
>
> 这个转译器是Gary Kildall写的，如果计算机科学领域有悲剧英雄的话，那肯定是他了。Gary Kildall作为第一批嗅到微机广阔前景的人之一，他为微机创造了第一个高级语言和操作系统，PL/M 和 CP/M。
>
> 他是一个航海船长，商业领袖，版权先锋和摩托车手。他还是一个有着Kris Kristofferson类似长相的电视主持人，在80年代作为颇有风度的胡子男给人留下了美好的印象。他曾比肩比尔盖茨，但像很多人一样，他迷失了，最后在一家骑手酒吧里以其他的方式死去。他死的太早了，但他生前过的也很不好。

虽然第一个转义器是把一门汇编语言翻译成另一门汇编，但是如今很多转译器大都用在高级语言层面。随着UNIX系统在各种杂七杂八的机器上病毒式传播，在很长的时间里编译器把C语言当成了它们的输出语言。只要有UNIX，C编译器就能生成高效的代码，所以把C语言作为目标语言是一种让你的语言迅速在各种机器上跑起来的好方法。

如今Web浏览器成了上面所言的“机器”，而JavaScript则成了对应的“机器码”。所以现在几乎所有语言都有一个编译成JS的编译器，毕竟这是让你的语言在浏览器上跑的唯一方法。

> JS可能不再是浏览器唯一原生支持的语言。如果Web汇编能落地，那么流浪器将支持其他低级语言，尤其作为编译器编译目标的语言。

转译器的前端，即扫描器和解析器，看起来和其他编译器很像。接着，如果源语言仅仅只是目标语言的一层语法皮，那么他可能直接跳过分析阶段，直接输出与目标语言类是的句法。

如果两种语言语法非常不一样，那你会看到很多完整的编译器里的典型阶段，比如分析，优化等等。然后到了代码生成阶段，你会生成一个语法无误的目标语言源码，而不是像以前输出像机器码这样的二进制语言。

这两种方式最后都会用已有的目标语言编译器管道来跑我们生成的代码，后面就没你什么事了。

### 即时编译

最后一个不太像捷径，更像一个为专家准备有有挑战性的斜坡。执行代码最快的方式是编译成机器码，但如果你不知道用户机器的架构要怎么办呢。

你可以像HotSpot Java虚拟机，微软的CLR和大部分JavaScript解释器那样做。在用户机器端，在程序加载的时候，他们不是以JS的源码形式或者像JVM和CLR那样平台无关的字节码形式加载的，而是编译成他们本地机器架构支持的代码。很自然的，这种做法称之为即是编译，很多hacker喜欢叫“JIT”，发音和“fit”押韵。

最精致的JIT会把配置好的钩子加紧生成的代码中，来看那块区域有性能缺陷并且看看处理的数据类型又是怎样的。然后他们过后会对这些热点内容用更高级的优化手段重新编译。

> HotSpot JVM 的名字就是这么来的

## 编译器和解释器

既然我已经让你知道了编程语言的术语的重要性，那么我们终于可以问出那个一直以来困然着编码者的问题：“编译器和解释器之间有什么区别？”

这其实有点像在问水果和蔬菜有什么区别。这看起像是二元选项，但实际上，水果是植物学的概念二蔬菜是烹饪领域的概念。这两者并不是对立的。有些水果它不是蔬菜，比如苹果，有些蔬菜也不是水果，比如胡萝卜，但有些可食用的植物即使水果也是蔬菜，比如番茄。

![A Venn diagram of edible plants](http://craftinginterpreters.com/image/a-map-of-the-territory/plants.png)

> 有时植物两者都不是，比如坚果和谷物（花生甚至还不是坚果）

所以，回到语言上面：

* 编译器是把源码语言翻译成其他语言（通常是更低级的语言）的实现工具。当你生产字节码或者机器码的时候，你就是在编译。当你转译成其他高级语言的时候，你也是在编译。
* 当我们说一个语言实现是一个编译器，我们是说把源码转换成其他形式当并不执行它。使用者需要自己去运行输出的结果。
* 相反的，当我们说一个实现是一个解释器时，我们是在说接收源码并运行它，也就是它从源码运行程序。

就像苹果和橙子一样，有些实现很清楚的是编译器而不是解释器。GCC 和 CLang 把你的C代码编译成机器码。用户端直接运行这些可执行程序，他们并不需要知道是哪些工具编译的。那些就是C编译器。

在早期版本，Matz 的Ruby权威实现里，用户直接从源码跑Ruby语言。这种实现解析与源码并通过遍历语法树来运行它。没有其他翻译产物，内部没有，用于可见的形式也没有。所以我们把它定义为Ruby解释器。

但是CPython是什么呢。当你用它来跑你的Python程序时，代码被解析和转换成一种内部字节码的形式，接着在虚拟机中执行。从用户角度看，这很显然是一个解释器，它从源码直接跑程序。但如果你掀开Cpython的鳞片往里看，你就可以看到一些编译过程在里面。

答案是，二者皆可。CPython是一个解释器，同时它有一个编译器。实际上，大部分脚本语言都是这样的，如下图所示：

> Go 工具更是个园艺珍品。如果你跑go build，他把你的go 代码编译成机器码然后终止。如果你跑go run，他会先编译再运行产出的可行性文件。
>
> 所以go tool是一个编译器（你能把它当成一个编译工具，而不用运行它），也是一个解释器（你可以启动它来直接从源码跑你的程序），而且包含一个编译器（你如果你把它当成解释器，那它内部还是有编译过程）

![A Venn diagram of compilers and interpreters](http://craftinginterpreters.com/image/a-map-of-the-territory/venn.png)


中间重叠的部分也是我们第二个解释器的呆的位置，因为它内部把源码编译成字节码。所以当这本书名义上是些解释器的，但我们也会覆盖一些编译的内容。

### 我们的旅程

突然间有很多内容加进来了。但不需要担心，这一章并不要求你理解其中的所有内容，我只是希望你对这些概念有基本的了解以及它们之间是如果关联的。

当你在本书的指导路径之外探索语言领地时，这张地图会对你有很大的帮助。我希望能激起你自己攀登语言山峰遍历所有山脉的渴望。

但现在，是时候开始我们的旅程了。绑紧你的鞋带，背上你的背包，跟我来吧。从现在开始，你唯一需要关心的就是你眼前的路。

> 从现在开始，我保证会减少拿山峰来做比喻



### 测验

1. 选一门开源的语言，把源码下下来看。试着找出扫描器和解析器的实现，看看他们是手写的还是用类似Lex或者Yacc工具生产的（后者会有 .l 和 .y文件）
2. 即时编译差不多是实现动态类型语言最快的方式，但不是所有语言都用它，为什么？
3. 很多编译成C的Lisp语言编译器实现也会包含一个解释器来执行Lisp代码，为什么会这样？

