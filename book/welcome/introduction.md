# 介绍

> 童话之所以真实，不仅因为它们让我们知道龙是存在的，还因为它们告诉我们龙是能被战胜

我们能一起共赴这段旅程是一件令人兴奋的事。这是一本实现编程语言解释器的书，同时也是一本如何设计一门好语言的书。当我第一次深入编程语言的时候我希望有这样的书，写这本书的念头萦绕在我脑海很多年了。

在这些篇章里，我们将一步步的走过两个完整解释器的实现历程。我假定这是你们第一次涉足语言，所以我会事无巨细地讲解每一个概念和每一行实现代码，以期你们能够完全理解一个完整的，可用的，高效的语言是怎么实现的。

为了把两个完整的实现过程放进这本书且还避免篇幅过长，该书理论层面的内容会相对少点。但对于我们创建的系统的每一模块，我会介绍它们背后的历史和概念。我也会试着让大家能够熟悉这些行话，这样你们以后参加程序语言研究的鸡尾酒舞会时就能游刃有余了。

但我们主要精力还是花在语言设计和运行上。这不是说理论不重要。在语言研究上，准确而有条理的分辨各种语法和语义是一项重要的技能。但从我个人的角度上，我边做边学会做的更好些。我很难读完并吸收充斥着各种抽象概念的段落，但如果让我写点代码，运行，调试，那我就学会了。

这也是我对你们的期待。我希望你看完之后对一门真正的语言如何呼吸能有全面的观感，同时也希望你们在后续再读其他理论书籍时，那些概念能牢牢的印在你脑海中，依附在这些本书所学的基石之上。



## 为什么学这个东西

每一本编程语言书籍似乎都会有这一篇。我不知道是什么东西会引起对编程语言存在的怀疑。我不认为一本鸟类学的书籍需要告诉别人存在的合理性，它本身就假定了阅读该书的人就是一个鸟类爱好者。

但编程语言有点特殊。我认为我们不太可能创造出一个成功的广泛使用的编程语言。这个世界上，能够设计出广泛使用的编程语言的人大概能装进一辆通用汽车，甚至不用把顶棚的帐篷打开。如果你把加入这种精英阵营作为学习语言的唯一目标，那这书确实很难说能助你达成目前。幸运的是，我们学习语言有其他目的。

### 微语言到处都是

每一个成功的多功能语言都成千上万个小特性。我们称这些特性为“微语言”，但因为行话效应，人们慢慢地称呼他们为“领域专用语言”。这些混杂的语言诸如：应用脚本语言、模版引擎、格式配置、文件配置等等。

![A random selection of little languages.](http://craftinginterpreters.com/image/introduction/little-languages.png)

几乎所有大型的软件项目都需要一堆这些微语言。尽可能的重用已经存在的语言而不是重复去造轮子。一旦你考虑到文档说明，调试，编译器支持，语法高亮和其他可能的坑，你就会明白一个人做出这些东西是多么艰难。

但还是有可能，某天你突然想用一个解释器或其他东西却找不到任何能满足你要求的库。即使有一个能重用的，也很难避免无止境的调试，维护以及陷入库代码满屏的细节之中。

### 语言是良好的锻炼

长跑者有时会在脚踝绑上沙袋或者到空气稀薄的高海拔地区训练。当他们卸掉负担时，轻盈的脚步和充足的氧气能让他们跑的更快更远。

实现一门语言是对编程技能一次真正的测验。代码十分复杂同时性能要求也很苛刻。你必须管理递归，动态数组，树，图形，哈希表。哈希表你可能天天都在用，但你是否真正的理解它背后的原理呢。别担心，在我们苦思冥想之中掌握语言这门技艺后，我保证所有这一切你都会了然于心。

虽然我像你展示了编程语言并没有你想象的那么可怕，但它仍旧是一项挑战。正面面对它，你会成为一名更优秀的编程者，并且在你的日常工作中你会更聪明合理地使用结构和算法。

### 另一个原因

对于我来说最后一个原因难以启齿，因为它在我内心非常隐秘的地方。曾经我还是一个孩子的时候，初学编程，我感觉编程语言似乎有种道不清的魔力。有时候我打出BASIC的一个关键字，我想不出来BASIC是怎么做到的。

后来，怀着对我大学朋友编译课程的敬畏和恐惧，我逐渐相信那些和语言打交道的人一定是另一个人种。像是某类获取了特殊令牌的男巫，优先进入了语言这个神秘艺术的大门。

那是一副吸引人的愿景，但它也有黑暗的一面。我不觉得我像一个男巫，所以我觉得我缺少某种与生俱来的特质去加入他们的小团体。即使如此，当我在笔记本上随意的画出关键字时，我还是被语言深深的吸引了。多年之后我才鼓起勇气试着真正的了解它们。

当我最终开始尝试缝补我的小小的解释器时，我发现里面一点魔法都没有，只是代码而已，和语言打交道的人也只是普通人。

有些技术你可能在学习语言时会遇到，还有一些部分可能有些困难，但也不会比你曾经克服的障碍难多少。我的希望是，如果你曾经对语言感到恐惧，我希望这本书能帮助你战胜它们，让你比以前更加勇敢些。

或者，你还可能因此创造出下一个伟大的语言，谁知道呢。有人就这么干过。

## 这本书的结构

本书分为3个部分，你现在已经在看第一部分了。这一部分有几个章节会给你一个大致的方向，教给你一些hacker们常用的术语，介绍下我们后面要实现的Lox 语言。

剩下的两个部分各实现一个复杂的Lox 解释器。在那两部分里，每一章节的结构都是类似的。每个人都可以随意选取一个语言特性，了解背后的概念然后亲历整个实现过程。

对我来说这将是一个艰难的不断试错的过程，但我还是会设法将两个解释器的实现写成一个个篇章大小，尽量让每一个篇章的实现都建立在上一篇章的基础上。在第一章节里，会有一个完整的程序让你运行、瞎鼓捣，往后的章节里，会逐步完善特性，直到最终完成一个完整的语言。

除了大量的精美英文短语，每一章节还有一下几个亮点：

### 代码

既然我们准备写解释器了，很自然书里会包含真正的代码。每一行解释器所需的代码都包含在内，并且还会告诉你应该把代码加载你的解释器的哪一个位置。

很多其他的语言书和语言的实现方式都是用类似Lex 和Yacc 这样的工具。这类“编译编译器”工具负责把更高层级的描述信息自动翻译成语言实现层级的源文件。这些工具都有优缺点，大家对这些优缺点都有自己的近乎宗教信仰的意见。

> Yacc 可以理解语法文件并生成编译器的源文件，它有点像一个生成编译器的编译器，所以我们才会叫它“编译编译器”
>
> Yacc不是这类型工具的第一个，这也是是为什么叫Yacc这个名字（Yet Another Compiler-Compiler 另一个编译编译器）。之后又有一个类似的工具叫Bison（野牛），名字取自Yacc的音似名词Yak（耗牛）。
>
> ![A yak.](http://craftinginterpreters.com/image/introduction/yak.png)
>
> 如果你觉得这些引申知识和双关语很有趣，那你应该很容易适应本书后续的内容。如果不是，那好吧，或许一个语言呆子的幽默感是一种习得的品味。

在这里我们会避免使用这些工具。我想确保那些魔法和困惑无处躲藏，所以我们会手写所有东西。这听起来很可怕，但很快你就会知道，这意味着你将完全理解每一行代码并熟知两个解释器是如何工作的。

书本的限制和真实情况总是不大相同，所以本书的代码风格可能不是一个可维护软件的最好实现方式。如果我漏了写private关键字或者没有声明一个全局变量，相信我，我只是想让你们看代码更容易些。这里的篇章并不像你的ide那么聪明，每一个字符都无可挑剔。

同样的，这里的代码没有太多注释，这是因为每段代码都会有好几个段落来解释它。当你自己写书时，你也会很乐意删掉附在书中的代码注释，否则你可能会写更多的 // 在上面。

这本书没有包含编译和运行代码的构件。我假设你们已经配置好了makefile 或者ide来运行这些代码。

### 代码片段

因为这本书几乎包含了实现所需的每一行代码，所以代码片段是相当清晰的。除此之外，为了保持可运行的状态，我还会给半成品的程序加些后续会替代的临时代码。

一个酷炫的代码段大概长这个样子：

```
default:
      						 						lox/Scanner.java
       												in scanToken()
       												replace 1 line
```

>  if (isDigit(c)) {
> ​          number();
> ​        } else {
> ​          Lox.error(line, "Unexpected character.");
> ​        }

```
	brek;
```

中间是新加入的代码，上下两段代码用来标明新代码加入的位置，旁边还有一些说明告诉你操作的文件名和文件路径。如果出现“replace _ lines”字段，那就说明你需要拿中间这段代码替换掉原来的在这个位置上的代码。

###  注释

注释包括一些人物的概述，历史背景，相关话题的引申资料和探索其他领域的一些建议。在后面的内容，你可以跳过这些注释，不了解注释的内容也没关系。我不会评判你，只是我会有点伤心。

> 好吧，有些注释确实挺重要。但大部分只是一些蠢萌的笑话和业余的胡乱涂画。

### 测验

每一个章节的后面都有一些小测试。 不像教科书那样考你已经掌握的知识，这里的测验是为了帮助你学到更多章节之外的内容。这些测验会使你脱离原有的引导路线，自己去探索新的领域。你也会研究其他的语言，找出实现某些特性的方法，否则你只能靠自己苦思冥想了。

克服这些困难你会对语言有更深的理解，或许还能碰撞出不一样的火花。或者你也可以跳过，继续呆在这辆旅行巴士的舒适区里。任君选择。

###  设计小建议

大部分的“编程语言”书籍就是严格意义上的如何实现编程语言的书。他们很少讨论对于实现的语言要如何设计。实现确实是件有趣的事情但他太精确太死板了。我们编程者似乎大都喜欢非黑即白的东西。

> 我知道很多语言黑客赖以为生。你在他门口留下一门语言的规则，等几个月，代码和标准结果就从会门内送出来。

我个人觉得，这个世界唯一需要的就是各种FORTRAN 77 的实现。在某些节点，你可能觉得自己在设计一门全新的语言，但一旦你开始这种游戏，很快你会发现天平的另一面软性的人性相关的问题变得至关重要。诸如什么特性容易上手，如何平衡创新和习惯，什么用的语法更可读以及对谁而言可读。

> 所幸的是，一门语言并不会把假定的大孔卡尺寸硬编码进它的语言。

所有这些事情极大地影响这你这门新语言是否成功。我希望你的语言能够脱颖而出，所以在某些章节的后面我会贴一些有关人性和编程语言的小短文。我不是这方面的专家（我也不知道谁才是专家），所以我希望你对这些内容太过较真。至少这会使这本书读起来更有味道，我的目的也仅限于此。

## 第一个解释器

我们会用java来写我们的第一个解释器，jlox。这个解释器，我们主要精力放在概念上。我们会用尽可能简单干净的代码来正确地实现这门语言的语义。这会让我们熟知基本的技术以及夯实我们对一门语言如何运作的理解。

Java 很适合来做这件事。Java层级足够高，不至于让我们淹没在繁琐的实现细节之中，同时不丢失语言的简练。不像脚本语言，Java没有那么多巫师帽下的神奇魔法，你也可以通过java的静态类型知道你用的是什么数据类型。

选择java的另一个原因是它是面向对象的语言。这种范式在上世纪90年代横扫编程世界，如今已主导着成千上万编程者的思考方式。你很有可能已经习惯了使用类和方法来思考，所以本书也将保持这一习惯，让你继续呆在舒适区中。

尽管学院语言派系有时会看不起面向对象语言，但他们被广泛运用在语言工作中已是不争的事实。GCC 和 LLVM 编译器是用C++写的，大部分JavaScript的虚拟机也是如此。面向对象语言随处可见，并且很多语言工具和编译器也是用这类型的语言写的。

> 编译器从文件中读入一种语言，转换成另一种语言后输出到另一文件。你可以用任何语言来实现编译器，甚至可以用编译器要编译的语言，这个做法叫做自我托管（self-hosting）。
>
> 一开始你做不到自我编译，但你可以先用另一种语言来编译你写的语言编译器。一旦你拥有了自己的语言编译器，你就可以用它来编译自己的语言，原先的另一种语言写的编译器就可以不用了。这种做法我们称之为“靴带现象”，就像下图所示，通过拉自己的靴子把自己提了起来。

![Fact: This is the primary mode of transportation of the American cowboy.](http://craftinginterpreters.com/image/introduction/bootstrap.png)

回到正题。Java已经很普及了，这意味着你很可能已经知道它，所以你不需要学习太多铺垫知识就可以开始本书的学习了。如果不对Java不熟也不用惊慌。我会尽量使用Java的最小子集来写解释器。比如我用了Java 7 中的菱形操作符来让代码更简洁些，但这已经是相对本书而言十分“高级”的特性了。如果你了解C++，C#之类的其他面向对象语言，你也会很容易蒙混过去的。

到第二部分结束，我们会完成一个简单，可读性强的解释器实现，只是效率可能不怎么好。这个解释器还依赖java虚拟机的运行时机制，但我们想知道java自己是怎么实现这些东西的。

## 第二个解释器

下一个部分，我们会从头开始，只不过这次用的是C语言。C 语言可以让我们很好的理解解释器是如何工作的，以及内存字节的组织形式和代码与CPU的交互过程。

另一个使用C语言的重要原因是，我能向你展示一些C特别擅长的东西，但这也意味着你需要对这么语言非常熟悉才行。你不需要Dennis Ritchie附体，但你也不应该被指针所吓倒。

如果你没有准备好，选本C语言的入门书籍并仔细地消化它，等你做完这些再回来这里。最为回报，你从这本书走出来后会成为一个更优秀的C程序员。这对你很有帮助，因为很多语言实现都是用C的，Lua，CPython，Ruby's MRI 不胜枚举。

在C解释器clox中，我们将集中精力实现所有java帮我们实现了的东西。我们会自己写动态数组和哈希表。我们会规定对象在内存的分配方式，并创建一个垃圾回收器来回收它们。

> clox，我发音有点像“sea-locks”，但你可以说“clocks” 甚至 “clochs”。后者听起来像希腊语，随你开心怎么叫都行。

我们的Java版本的实现专注于正确运行。现在我们更进一步，我们要求更高的执行效率。我们的C解释器包含一个把代码翻译成可以运行的高效字节码的编译器。这也是实现Lua，Python，Ruby，PHP，等其他成功语言的技术。

> 你觉得这本书只是讲解释器吗？不，它也是一本有关编译器的书籍。加量不加价！嘻嘻

我们也会着手测试和优化。最终，我们会拥有一个稳定，精确，高效的lox语言解释器，足够和其他优秀的解释器比肩。这也不枉费此书和几千行代码。



###  测验：

1. 拼接这个编写和发行此书的小系统我至少用了六种领域专用语言，它们分别是什么？
2. 用Java写一个“Hello，world” 程序，随便什么makefiles和IDE工具。如果你有调试工具，熟悉它，用单步调试知道程序成功跑起来。
3. 同样也用C写一个这样的程序。练习下指针，定义一个堆内存字符串的双向链表。实现增删改查方法并测试它们。


### 设计建议：如何取个好名字

写这本书最大的挑战之一就是怎么给要实现的语言取一个好名字。我写了好几页纸的名字才找到凑合能用的。当你打算写自己的语言是，你在第一天就会发现取名是多么难的一件事。一个好名字满足以下几点：

1. **没有被占用。** 如果你占用了某人的名字，那会陷入各种麻烦之中，法律的社会的等等。
2. **容易发音**。如果事情发展顺利，会有一大帮人说你的语言写你的语言。过多的音节或者太多的字母会永无止境的困扰着人们。
3. **让人很清晰地搜索到**。人们会去google 你的语言来寻找相应地文档，所以你应该要找一个少见的单词让搜索结果里大都是关于你的语言的。尽管现在大部分的搜索引擎已经十分智能了。毕竟一个叫做“for”的语言不会给人们任何帮助。
4. **确保在众多文化中没有消极的意义**。这很难保证，但是是值得考虑的事情。Nimrod 的设计者把名字改成了“Nim”就是因为太多人只记的兔八哥里把“Nimrod”作为羞辱的代名词。

如果你潜在的名字可以通过以上残酷考验，留着它。不要花太多精力在试图找一个符合你语言所有特性的名词。如果一门世界级语言的名字可以教给我们一些事情，那肯定是名字并不是多重要的东西。你需要的不过是一个合理的独立无二的象征而已。

